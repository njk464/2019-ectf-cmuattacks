#!/usr/bin/env python3

import os
import argparse
import re
import subprocess
import base64
import hmac
import hashlib
import binascii
from Crypto.Cipher import AES
from Crypto.Util import Counter

# Path to the generated games folder. Games in this folder are encryted and authenticated.
gen_path = "files/generated/games"

# Path to the generated tempory games. Games in this folder are encrypted, but not authenticated.
tmp_path = "files/generated/tmp"

# key1 is the AES CTR encryption key. key2 is HMAC_SHA256 authentication key.
def provision_game(line, key1, iv1, key2):
    """Given a line from games.txt, provision a game and write to the
    appropriate directory

    line: string from games.txt to create a game for
    """
    # Regular expression to parse out the necessary parts of the line in the
    # games.txt file. The regular expression works as follows:
    # 1. Match a file name and capture it
    # 2. Skip over any whitespace
    # 3. Match the game name and capture it
    # 4. Skip over whitespace
    # 5. Match the group (major.minor)

    reg = r'^\s*([\w\/\-.\_]+)\s+([\w\-.\_]+)\s+(\d+\.\d+|\d+)((?:\s+\w+)+)'
    m = re.match(reg, line)
    if not m:
        return

    # Path to the game
    g_path = m.group(1)
    # Name of the game
    name = m.group(2)
    # Game version
    version = m.group(3)
    # List of users (strings) that are allowed to play this game
    users = m.group(4).split()

    # Open the path to the games in binary mode
    try:
        f = open(g_path, "rb")
    except Exception as e:
        print("Error, could not open game: %s" % (e))
        exit(1)

    # The output of the game into the file should be:
    # gamename-vmajor.minor
    f_out_name = name + "-v" + version
    # Open the output file in binary mode
    try:
        f_out = open(os.path.join(tmp_path, f_out_name), "wb")
    except Exception as e:
        print("Error, could not open game output file: %s" % (e))
        f.close()
        exit(1)

    # Write the game header to the top of the file
    # The game header takes the form of the version, name, and user information
    # one separate lines, prefaced with the information for what the data is
    # (version, name, users), separated by a colon. User information is space
    # separated
    # For example:
    # version:1.0
    # name:2048
    # users:drew ben lou hunter
    f_out.write(bytes("version:%s\n" % (version), "utf-8"))
    f_out.write(bytes("name:%s\n" % (name), "utf-8"))
    f_out.write(bytes("users:%s\n" % (" ".join(users)), "utf-8"))

    # Read in the binary source and pad
    g_src = f.read()
    game_size = f.tell()
    padding_size = 0

    if (game_size % 16):
        padding_size = 16 - (game_size % 16)
        g_src += bytes(padding_size)

    # ENCRYPTS the game binary using KEY_1, AES-CTR
    print("Encrypting Game...")
    ctr = Counter.new(128, little_endian=False, initial_value=0)
    encryption_suite = AES.new(key1, AES.MODE_CTR, counter=ctr)
    g_src = encryption_suite.encrypt(g_src)

    # Write the binary source
    while g_src:
        f_out.write(g_src)
        g_src = f.read()

    # Close the files
    f_out.close()
    f.close()

    print("    %s -> %s" % (g_path, os.path.join(tmp_path, f_out_name)))

    # Add HMAC-SHA256 digest to the header
    # The game header takes the form of the base64 encoded hmac, version, name, and user information
    # one separate lines, prefaced with the information for what the data is
    # (hmac, version, name, users), separated by a colon. User information is space
    # separated
    # For example:
    # hmac:eeTiN7Ew6RxOFhfz6UlLAwPM+PnWnnIr4E5M7Rj6Qck=
    # version:1.0
    # name:2048
    # users:drew ben lou hunter

    try:
        f_tmp = open(os.path.join(tmp_path, f_out_name), "rb")
    except Exception as e:
        print("Error, could not open tmp game file: %s" % (e))
        exit(1)

    try:
        f_out = open(os.path.join(gen_path, f_out_name), "wb")
    except Exception as e:
        print("Error, could not open game output file: %s" % (e))
        exit(1)

    # Read in the binary source and pad
    body = f_tmp.read()
    digest = hmac.new(key2, body, hashlib.sha256).digest()
    f_out.write(bytes("hmac:%s" % (binascii.b2a_base64(digest).decode('ascii')), "utf-8"))

    # Write the binary source
    while body:
        f_out.write(body)
        body = f_tmp.read()

    # Close the files
    f_out.close()
    f_tmp.close()

    print("    %s -> %s" % (g_path, os.path.join(gen_path, f_out_name)))


def main():
    # argument parsing
    parser = argparse.ArgumentParser()
    parser.add_argument('factory_secrets',
                        help=("This file is the FactorySecrets.txt file "
                              "generated by provisionSystem.py"))
    parser.add_argument('games',
                        help=("A text file containing game information in a "
                              "MITRE defined format."))
    args = parser.parse_args()

    # open factory secrets
    try:
        f_factory_secrets = open(args.factory_secrets, "r")
    except Exception as e:
        print("Couldn't open file %s" % (args.factory_secrets))
        exit(2)

    # Open the games file
    try:
        f_games = open(args.games, "r")
    except Exception as e:
        print("Couldn't open file %s" % (args.games))
        f_factory_secrets.close()
        exit(2)

    subprocess.check_call("mkdir -p %s" % (gen_path), shell=True)

    print("Provision Games...")

    # Read base64 encoded secrets from FactorySecrets.txt, and decode them
    key1 = f_factory_secrets.readline()
    iv1 = f_factory_secrets.readline()
    key2 = f_factory_secrets.readline()
    key3 = f_factory_secrets.readline()

    key1 = base64.b64decode(key1)
    iv1 = base64.b64decode(iv1)
    key2 = base64.b64decode(key2)
    key3 = base64.b64decode(key3)

    # Provision each line in the games file
    for line in f_games:
        provision_game(line, key1, iv1, key2)

    print("Done Provision Games")

    exit(0)


if __name__ == '__main__':
    main()

